<h1 align="center">Мини документация по проекту (или ее подобие)</h1>
<h3>Модели в проекте:</h3>
<ul>
  <li><h5>Модель Категорий</h5></li>
  <li><h5>Модель Поставщиков</h5></li>
  <li><h5>Модель Продуктов</h5></li>
  <li><h5>Модель Транзакций</h5></li>
</ul>
<h3>Чекпоинты api</h3>
<ul>
  <li><h5>домен/api/category/</h5></li>
  <li><h5>домен/api/category/id/</h5></li>
  <li><h5>домен/api/supplier/</h5></li>
  <li><h5>домен/api/supplier/id/</h5></li>
  <li><h5>домен/api/product/</h5></li>
  <li><h5>домен/api/product/id/</h5></li>
  <li><h5>домен/api/stockmovement/</h5></li>
  <li><h5>домен/api/stockmovement/id/</h5></li>
</ul>
<h3>У каждого GET запроса можно включить параметр format в ссылке для получения ответа в формате csv или xlsx</h3>
<h5>Пример: домен/api/product/?format=csv</h5>
<h3>Требования к запросам</h3>
<ul>
  <li>
    <h3>Category-создание:</h3>
    <ul>
      <li>ключ словаря json | name | строка</li>
      <li>заголовок запроса | Authorization: token токен_любого_пользователя</li>
    </ul>
  </li>
  <li>
    <h3>Supplier-создание:</h3>
    <ul>
      <li>ключ словаря json | name | строка</li>
      <li>ключ словаря json | category | число (айди категории)</li>
      <li>заголовок запроса | Authorization: token токен_любого_пользователя</li>
    </ul>
  </li>
  <li>
    <h3>Product-создание:</h3>
    <ul>
      <li>ключ словаря json | name | строка</li>
      <li>ключ словаря json | supplier | число (айди поставщика)</li>
      <li>ключ словаря json | sku | число (уникальный айди товара который не должен быть занят)</li>
      <li>ключ словаря json | price | число </li>
      <li>заголовок запроса | Authorization: token токен_любого_пользователя</li>
    </ul>
  </li>
  <li>
    <h3>StockMovement-создание:</h3>
    <ul>
      <li>ключ словаря json | operator_email | строка (валидный email)</li>
      <li>ключ словаря json | product | число (айди товара)</li>
      <li>ключ словаря json | date | строка-дата (не обязательно к заполнению, не может быть будущая, формат даты: ISO 8601)</li>
      <li>ключ словаря json | quantity | число (не может быть равным нулю)</li>
      <li>ключ словаря json | note | строка (описание транзакции, не обязательно к заполнению)</li>
    </ul>
  </li>
  <li>
    <h3>StockMovement-редактирование/удаление:</h3>
    <ul>
      <li>заголовок запроса | Authorization: token токен_любого_пользователя</li>
    </ul>
  </li>
</ul>
<h3>Информация для тестов postman!</h3>
<h5>В проекте имеется файл с postman окружением и postman коллекцией. Для работы коллекции нужно использовать приложенное к проекту окружение. Для того чтобы тесты успешно провелись нужно соблюсти 2 вещи:</h5>
<ul>
  <li><h5>Указать существующий токен пользователя в окружении postman (для этого нужно после запуска проекта создать любого пользователя командой python3 manage.py createsuperuser --username *username* и получить его токен командой python manage.py drf_create_token *username*). Токен должен быть указан в postman переменной окружения token в формате: token сам_токен </h5></li>
  <li><h5>Сделать все тесты удаления объектов самыми последними (иначе будут проблемы с зависимостями). Правильный порядок тестов удаления: delete_stockmovement, delete_product, delete_supplier, delete_category</h5></li>
</ul>
<h3>Информация для тестов django!</h3>
<h5>Из-за кривой попытки сделать универсальный шаблон для теста всех моделей и конфликта названий функций (названий тестов в файле tests.py) нельзя запускать классов-тестов одновременно.</h5>
<h5>Пример правильного запуска тестов:<ul>
  <li><h5>python3 manage.py test api_v1.tests.CategoryTest</h5></li>
  <li><h5>python3 manage.py test api_v1.tests.SupplierTest</h5></li>
  <li><h5>python3 manage.py test api_v1.tests.ProductTest</h5></li>
  <li><h5>python3 manage.py test api_v1.tests.StockMovementTest</h5></li>
</ul></h5>
<h3>Дополнительно:</h3>
<h5>Пофиксить невозможность запуска нескольких тестов django за раз не сложно (просто расписать отдельные тесты для каждой из модели), но я решил это оставить чтобы возможно получить твою оценку (оценку Максима) реализации шаблонна для тестов моделей (Если в кратце, то оно реализованно через наследование. Так же для получения универсального sku в моделе Product я создал класс GenerateUniqueValue который занимается генерацией рандомного уникального параметра для модели (строки/числа))</h5>
<h5>Опциональную часть тз решил не делать потому что уж очень я не люблю JS из-за того что плохо его знаю) С Fetch я работал и если сильно захочу, то могу реализовать через него взаимодействие с api, но все же немного лень). Так же возможно в каких то моментах я не правильно понял какую то часть тестового задания.</h5>
